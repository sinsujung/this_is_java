# 6.1 객체지향 프로그래밍

# 6.1.1 객체란?

- 객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다.
- 객체는 속성과 동작으로 구성되어 있고 자바는 이 속성과 동작들을 각각 필드와 메소드라고 부른다.
- 객체를 소프트웨어 객체로 설계하는 것을 모델링이라고 한다.
- 객체 모델링은 현실 세계 객체의 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로  정의하는 과정이다.

# 6.1.2 객체의 상호작용

- 객체들은 각각 독립적으로 존재하고 다른 객체와 서로 상호작용하면서 동작한다.
- 객체들 사이의 상호작용 수단은 메소드
- 객체가 다른 객체의 기능을 이용하는 것은 메소드 호출

- 메소드 호출은 객체에 도트(.) 연산자를 붙이고 메소드 이름을 기술하면 된다.

```jsx
리턴 값 = 전자계산기객체.메소드(매개값1, 매개값2, ...);

int result = Calculator.add(10,20);
```

- 매개값은 메소드를 실행하기 위해 필요한 데이터다.

# 6.1.3 객체 간의 관계

- 객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다.
    - 집합 관계, 사용 관계, 상속 관계
- 집합 관계에 있는 객체는 하나는 부품이고 하나는 완성품에 해당한다.
    - 엔진,타이어,핸들 등으로 구성되므로 자동차와 이부품들은 집합의 관계
- 사용 관계는 객체 간의 상호작용을 말한다.
- 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다.
    - 사람은 자동차를 사용하므로 사람과 자동차는 사용관계
- 상속 관계는 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계
    - 일반적으로 상위 객체는 종류, 하위 객체는 구체적인 사물
    - 자동차는 기계의 종류이다 에서 기계(상위)와 자동차(하위)는 상속 관계

# 6.1.4 객체 지향 프로그래밍의 특징

- 객체 지향 프로그램의 특징으로는 캡슐화, 상속, 다형성을 들 수 있다.

## 캡슐화(Encapsulation)

- 캡슐화란 객체의 필드, 메소드를 하나로 묶고 실제 구현 내용을 감추는 것
- 외부 객체는 객체 내부의 구조를 알지 못하여 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
- 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록하는 것이다.
- 자바 언어는 캡슐화된 멤버를 노출시킬지 숨길지 결정하기 위해 접근 제한자를 사용한다.
- 접근 제한자는 객체의 필드와 메소드의 사용범위를 제한함으로써 외부로부터 보호한다.

## 상속(Inheritance)

- 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 한다.
- 상속은 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고 이미 잘 개발된 객체를 재사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄여준다.
- 상위 개체의 수정으로 모든 하위 객체들의 수정 효과를 가져오므로 유지 보수 시간을 최소화 시켜준다.

## 다형성(Polymorphism)

- 다형성은 같은 타입이지만 실행 결과가 다양한 개체를 이용할 수 있는 성질
- 자바는 다향성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다.
- 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.
- 다향성의 효과로 객체는 부품화가 가능하다.
    - 자동차를 설계할 때 타이어 인터페이스 타입을 적용했다면 이 인터페이스를 구현한 실제 타이어들은 어떤것이든 상관없이 장착(대입)이 가능하다.

# 6.2 객체와 클래스

- 메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다.
- 설계도가 바로 클래스이다.
- 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.
- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다.
    - 자동차 객체는 자동차 클래스의 인스턴스
- 하나의 클래스로부터 여러개의 인스턴스를 만들 수 있는데 이것은 동일한 설계도로부터 여러대의 자동차를 만드는것과 동일하다.

- 사실 클래스는 객체를 만들기 위한 설계도였지만 객체로 만들어 보지는 않았다. 단순히 main()메소드만 작성해서 실행할 목적으로 클래스를 이용했다.
- 하지만 main() 메소드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야한다.

# 6.3 클래스 선언

- 사용하고자 하는 객체를 구상햇다면 그 객체의 대표 이름을 결정해 클래스 이름으로한다.
- 클래스 이름은 다른 클래스와 식별할 목적으로 사용되므로 자바의 식별자 작성 규칙에 따라 만들어야한다.
    1. 하나 이상의 문자로 이루어져야 한다.
    2. 첫 번째 글자는 숫자가 올 수 없다.
    3. ‘$’’_’ 외의  트수 문자는 사용할 수 없다.
    4. 자바의 키워드는 사용할 수 없다.
- 클래스 이름은 영어,한글 상관 없지만 보통 영어를 사용한다.
- 대소문자를 구분한다.
- 관례적으로 클래스 이름이 단일 단어라면 첫 자는 대문자 나머지는 소문자, 혼합된 이름은 각 단어의 첫 글자는 대문자

- 클래스 이름을 정했다면 “클래스이름.java”로 소스파일을 생성하고 소스 파일 이름은 클래스 이름과 대소문자가 같아야한다.
- 소스 파일을 생성했다면 소스 파일을 열고 다음과 같이 클래스 선언을 해준다.

```jsx
public class Car {

}

//public class는 반드시 소문자
```

- 두 개 이상의 클래스가 선언된 소스 파일을 컴파일 하면 코드 파일(. class) 클래스 선언한 개수만큼 생긴다.
- 결국 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다.
- 상기 코드를 컴파일 하면 Car.class Tire.class 가 각각 생성된다.
- 주의할 점은 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한을 붙일 수 있다.
- 만약 파일 이름과 일치하지 않는 클래스 선언에 public 접근 제한자를 붙이면 컴파일 에러가 발생한다.
- 가급적이면 소스 파일 하나의 동일한 이름 클래스 하나를 선언하는 것이 좋다

## 6.4 객체 생성과 클래스 변수

- 클래스를 선언한 다음 컴파일을 했다면( 이클립스에서는 저장) 객체를 생성할 설계도가 만들어진것이다.
- 클래스로부터 객체를 생성하는 방법은 new 연산자를 사용하면 된다.

```jsx
new 클래스();
```

- new는 클래스로부터 객체를 생성시키는 연산자이다.
- new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스()  형태를 가지고 있다.
- new 연산자로 생성된 객체는 메모리 힙 영역에 생성된다.
- 현실 세계에서 물건 위치를 모르면 물건을 사용할 수 없듯이 객체 지향 프로그램에서도 메모리 내에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다.
- 그래서 new 연산자는 힙 영역에 객체를 생성시킨 후 객체의 주소를 리턴하도록 되어있다.
- 이 주소를 참조 타입인 클래스 변수에 저장해두면 변수를 통해 객체를 사용할 수 있다.

```jsx
//클래스 타입으로 선언된 변수에 new 연산자가 리턴한 객체의 주소를 저장하는 코드

클래스 변수;
변수 = new 클래스();

//클래스 변수 선언과 객체 생성을 한 개의 실행문으로 작성

클래스 변수 = new 클래스();
```

- Student 클래스를 선언하고 StudentExample 클래스의 main() 메소드에서 Student 객체를 생성한다.

```java
//클래스 선언 Student.java
public class Student {

}
```

```java
//StudentExample.java 클래스로부터 객체 성

public class StudentExample {
	public static void main(String[] args) {
		Student s1 = new Student();
		System.out.println("s1 변수가 Student 객체를 참조합니다.");
		
		Student s2 = new Student();
		System.out.println("s2 변수가 또 다른 Student 객체를 참조합니다");
	}
}
```

- Student 클래스는 하나지만 new 연산자를 사용한 만큼 객체가 메모리에 생성된다.
- 이러한 객체들은 Student 클래스의 인스턴스들이다.
- 같은 클래스로부터 생성되었지만 각각의 Student 객체는 자신만의 고유한 데이터를 가지면서 활동하고 완전히 독립된 다른 객체이다.

- 클래스는 두 가지 용도가 있다.
    - 라이브러리용
        - 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다.
    - 실행용
        - 실행 클래스는 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할을 한다.
- 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리고 단 하나가 실행 클래스이다.
- Student는 라이브러리 클래스, StudentExample은 실행 클래스이다.
- Student에 main() 메소드를 작성해서 라이브러리인 동시에 실행 클래스로 만들 수도있다.

```java
public class Student {
//라이브러리로서의 코드(필드. 생성자, 메소드)
...

//실행하기 위한 코드
public static void main(String[] args) {
		Student s1 = new Student();
		System.out.println("s1 변수가 Student 객체를 참조합니다.");
		
		Student s2 = new Student();
		System.out.println("s2 변수가 또 다른 Student 객체를 참조합니다");
	}
}
```

- 프로그램이 단 하나의 클래스로 구성된다면 위와 같이 작성하는것이 좋지만
- 대부분 객체지향 프로그램은 라이브러리와 실행 클래스가 분리되어 있다.
- 가급적이면 두 클래스를 분리해서 작성할것이다.

# 6.5 클래스의 구성 멤버

- 클래스에는 객체가 가져야할 구성 멤버가 선언된다.
    - 필드, 생성자, 메소드
    - 생략이나 복수 개가 작성될 수 있다.

```java
public class ClassName {

//필드 객체의 데이터가 저장되는 곳
int fieldName 

//생성자 객체 생성 시 초기화 역할 담당
ClassName() {...}

//메소드 객체의 동작에 해당하는 실행 블록
void methodName() {...}

}
```

## 6.5.1 필드

- 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
- 선언 형태는 변수와 비슷하지만, 필드를 변수라고 부르지 않는다.
- 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다.
- 하지만 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸 되지 않는 한 객체와 함께 존재한다.

### 6.5.2 생성자

- 생성자는 new  연산자로 호출되는 특별한 중괄호{} 블록이다.
- 생성자의 역할은 객체 생성 시 초기화를 담당한다.
- 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다.
- 생성자는 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없다.

## 6.5.3 메소드

- 메소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.
- 중괄호 블록은 이름을 가지고 있는데 이것이 메소드 이름이다.
- 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
- 메소드는 필드를읽고 수정하는 역할도 하지만 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.
- 메소드는 객체간의 데이터 전달 수단으로 외부로부터 매개값을 받을 수도 있고 실행 후 어떤 값을 리턴할 수도 있다.

# 6.6 필드

- 필드는 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/de4e3c9d-6400-429e-87f8-eceb13c4cb90/e1552141-5f29-44e0-b705-e9b525cb475b/Untitled.png)

- 자동차 클래스를 설계할 때 이정보들은 필드로 선언되어야한다.

## 6.6.1 필드 선언

- 필드 선언은 클래스 중괄호 {} 블록 어디서든 존재할 수 있다.
- 하지만 생성자와 메소드 중괄호 블록 내부에는 선언될 수 없다.
- 생성자와 메소드 중괄호 블록 내부에 선언된 것은 모두 로컬 변수가 된다.
- 필드 선언은 변수의 선언 형태와 비슷하다.
- 그래서 클래스 멤버 변수라고 부르기도 하는데 될 수 있으면 필드라는 용어를 그대로 사용하자

```java
타입 필드 [= 초기값];

String company = "현대 자동차";
String model = "그렌저";
int maxSpeed = 300;
int productionYear;
boolean engineStart;
```

- 타입은 필드에 저장할 데이터의 종류를 결정한다.
- 기본타입 참조타입 모두 올 수 있다. 피드 초기값은 생략 가능
- 초기값이 지정되지 않은 필드들은 객체 시 자동으로 기본 초기값으로 설정된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/de4e3c9d-6400-429e-87f8-eceb13c4cb90/aacf9a4e-23fb-4c68-b2ad-752771039cc4/Untitled.png)

https://velog.velcdn.com/images%2Fmmy789%2Fpost%2F95e9e52f-359e-411e-b2ab-911f590d85cf%2Fimage.png

## 6.6.2 필드 사용

- 필드를 사용한다는 것은 필드값을 읽고 변경하는 작업을 말한다.
- 클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만 클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야한다.
- 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/de4e3c9d-6400-429e-87f8-eceb13c4cb90/3c992367-e0b5-4203-b61c-f58ac6b511b8/Untitled.png)

- Car 클래스의 speed  필드는 생성자와 메소드에서 변경이 가능하다.
- 사용방법은 변수와 동일한데 차이점은 변수는 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용할 수 있는 반면 필드는 생성자와 모든 메소드에서 사용이 가능하다.
- 외부 Person 클래스에서 Car 클래스의 speed 필드값을 사용하려면  Car 객체를 우선 생성해야한다,.

```java
Car myCar = new Car();
```

- myCar 변수가 Car 객체를 참조하게 되면 도트(.)연산자를 사용해서 speed 필드에 접근할 수 있다.
- 도트(.)연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드를 사용하고자 할 때 사용된다.

```java
myCar.speed = 60;
```

- Car 객체의 speed 필드값을 60으로 변경

```java
//Car.java Car 클래스 필드 선언

public class Car {
//필드
String company = "현대자동차";
String model = "그랜저";
String color = "검정";
int maxSpeed = 350;
int speed;
```

```java
//CarExample.java 외부 클래스에서 Car 필드값 읽기와 변경

public class CarEample {
	public static void main(String[] args) {
		//객체 생성
		Car myCar = new Car();
		
		//필드값 읽기
		System.out.println("제작회사: " + myCar.copany);
		System.out.println("모델명: " +myCar.model);
		System.out.println("색깔: " +myCar.color);
		System.out.println("최고속도: " + myCar.maxspeed);
		System.out.println("현재속도: " + myCar.speed);
		
		//필드값 변경
		myCar.speed = 60;
		System.out.println("수정된 속도: " + myCar.speed);
	
		}
	}
```

# 6.7 생성자

- 생성자는 new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.
- 객체 초기화란 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는것을 말한다.
- 생성자를 실행시키지 않고 클래스로부터 객체를 만들 수 없다.

## 6.7.1 기본 생성자

- 모든 클래스는 생성자가 반드시 존재하며 하나 이상을 가질 수 있다.
- 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 다음과 같이 중괄호 {} 블록 내용이 비어있는 기본 생성자를 바이트 코드에 자동 추가시킨다.

```java
//Car 클래스를 설계할 때 생성자를 생략하면 기본 생성자가 같 이 다음과 같이 생성된다.

//소스파일 Car.java
public class CAR {
}

//바이트 코드 파일 Car.class
public class Car {
	public Car {} //기본 생성자 Car() 자동추가
```

- 그렇기 때문에 클래스에 생성자를 선언하지 않아도 다음과 같이 new 연산자 뒤에 기본 생성자를 호출해서 객체를 생성시킬 수 있다.

```java
Car myCar = new Car();
								-----기본생성
```

- 클래스에 명시적으로 선언한 생성자가 한 개라도 있으면 컴파일러는 기본 생성자를 추가하지 않는다.
- 명시적으로 생성자를 선언하는 이유는 객체를 다양하게 초기화하기 위해서이다.

# 6.7.2 생성자 선언

- 기본 생성자 대신 우리가 생성자를 명시적으로 선언하는 법

```java
클래스 ( 매개변수선언, ...) {
//객체의 초기화 코드
}
```

- 생성자는 메소드와 비슷한 모양을 가지고 있으나 리턴 타입이 없고 클래스 이름과 동일하다.
- 생성자 블록 내부에는 객체 초기화 코드가 작성되는데 일반적으로 필드에 초기값을 저장하거나 메소드를 호출하여 객체 사용전에 필요한 준비를 한다.
- 매개 변수 선언은 생략할 수도 있고 여러개를 선언해도 된다.
- 매개변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.

```java
//Car 생성자를 호출할 때 세개의 값을 제공한다
Car myCar = new Car("그랜저", "검정",300);

```

- 두 개의 매개값은 String, 마지막 매개값은 int
- 세 매개값 을 생성자가 받기 위해서는 다음과 같이 생성자를 선언해야 한다.
-

```java
public class Car {
	//생성자
	Car(String model, String color, int maxSpeed) {...}
```

- 클래스에 생성자가 명시적으로 선언되어 있을 경우에는 반드시 선언된 생성자를 호출해서 객체를 생성해야한다.

```java
//Car.java 생성자 선언

public class Car {
	//생성자
	Car(String color, int cc) {
	{
	
}
```

```java
//CarExample.java 생성자를 호출해서 객체 생성

public class CarExample {
	public static void main(String[] args {
		Car myCar = new Car("검정색",3000)['
```

## 6.7.3 필드 초기화

- 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다.
- 만약 다른 값으로 초기화를 하고 싶다면 두 가지 방법이 있다.
    - 필드를 선언할 때 초기값을 주는 방법
        - 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 갖게된다.
        - 생성 후 변경할 수 있지만 생성 시점에는 필드의 값이 모두 같다.

        ```java
        public class Krorean {
        String nation = "대한민국";
        String name;
        String ssn;
        }
        
        -------------------------
        Korean k1 = new Korean();
        Korean k2 = new Korean();
        
        //Korean 클래스에 nation 필드를 선언하면서 대한민국으로 초기값을 준경우
        Korean 클래스로부터 k1,k2 객체를 생성하면 객체의 nation 필드에는 모두 대한민국이 저장되어있다.
        
        ```

    - 생성자에서 초기값을 주는 방법
        - 객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 한다면 생성자에서 초기화를 해야한다.

```java
public class Krorean {
//필드
String nation = "대한민국";
String name;
String ssn;
}

//생성자
public Korean(String n, String s) {
		name = n;
		ssn = s;
	}
}

//name과 ssn 필드값은 클래스를 작성할 때 초기값을 줄 수 없고 객체 생성시점에 다양한 값을 가져야한다
//따라서 생성자의 매개값으로 이값들을 받아 초기화한다.

Korean k1 = new Korean("박자바", "011225-1234567");

```

- Korean 생성자의 매개 변수 이름은 n,s를 사용했는데 관례적으로 필드와 동일한 이름을 갖는 매개 변수를 사용한다.
- 이경우 필드와 매개 변수 이름이 동일하기 때문에 생성자 내부에서 해당 필드에 접근할 수 없다.
- 이럴 경우 필드 앞에 this.를 붙이면 된다.
- this는 객체 자신의 참조인데 this.필드는 this라는 참조 변수로 필드를 사용하는 것과 동일하다.

## 6.7.4 생성자 오버로딩

- 생성자 오버로딩이란 매개변수를 달리하는 생성자를 여러개 선언하는 것을 말한다.

```java
public class Car {
	Car() {...}
	Car(String model) {...}
	Car(String model, String color){...}
	Car(String model, String color, int maxSpeed) {...}
```

- 주의할 점은 매개변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 생성자 오버로딩이라고 볼 수없다.
- 생성자가 오버로딩 되어 있을 경우 new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자가 결정된다.

```java
Car car1 = new Car();
Car car2 = new Car("그랜저");
Car car3 = new Car("그랜저", "흰색");
Car car4 = new Car("그랜저", "흰색",300);
```

## 6.7.5 다른 생성자 호출(this())

- 생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다.
- 이 경우에는 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
- 생성자에서 다른 생성자를 호출할 때에는 this()코드를 사용한다.

```java
클래스 ( [매개변수선언, ...] )
	this( 매개변수, ..., 값, ...);
	실행문;
	}
```

- this()는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용된다.
- this()의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야한다.
- this() 다음에는 추가적인 실행문들이 올 수 있다.
    - = 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 진행한다는 뜻

```java
//생성자 오버로딩에서 생기는 중복 코드를 제거해보자

Car(String model) {
	this.model = model;
	this.color = "은색";
	this.maxSpeed = 250;
}

Car(String model, String color) {
	this.model = model;
	this.color = color;
	this.maxSpeed = 250;
}

Car(String model, String color, int maxSpeed) {
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
}

```

- 세개의 생성자 내용이 비슷하므로 앞에 두 개의 생성자에서 this()를 사용해서 마지막 생성자인 Car(String model, String color, int maxSpeed)를 호출하도록 수정하면 중복 코드를 최소화할 수 있다.

```java
//Car.java 다른 생성자를 호출해서 중복 코드 줄이기

public class car {
	//필드
	String company = "현대 자동차"
	String model;
	String color;
	int maxSpeed;

	//생성자
	Car() {
	}

	Car(String model){
		this(model, "은색", 250);

	}

	Car(String model, String color){
		this(model, color, 250);

	}

	Car(String model, String color, int maxSpeed){
		this.model = model;
		this.coor = color;
		this.maxSpeed = maxSpeed;

	}
}

```

```java
//CarExample.java 객체 생성 시 생성자 선택

public class CarExample (
	public static void main(String[] args) {
		Car car1 = new Car();
		System.out.println("car1.company : " + car1.company);
		System.out.println();
		
		Car car2 = new Car("자가용");
		System.out.println("car2.company : " + car2.company);
		System.out.println("car2.model : " + car2.model);
		System.out.println();
		
		Car car3 = new Car("자가용", "빨강");
		System.out.println("car3.company :" + car3.company);
		System.out.println("car3.model : " + car3.model);
		System.out.println("car3.color : " + car3.color);
		
		Car car4 = new Car("택시", "검정",200);
		System.out.println("car4.company :" + car4.company);
		System.out.println("car4.model : " + car4.model);
		System.out.println("car4.color : " + car4.color);
		System.out.println("car4.maxSpeed : " +car4.maxSpeed);
```

### 6.8 메소드

<aside>
💡 메소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.

중괄호 블록은 이름을 가지고 있는데, 이것이 메소드 이름이다.

메소드를 호출하면 중괄호 블록에 있는 코드들이 일괄적으로 실행된다.

메소드는 필드를 읽고 수정하는 역할도 하지만, 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.

메소드는 객체 간의 데이터 전달의 수단으로 사용된다.

외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 리턴할 수도 있다.

</aside>

---

### 6.8.1 메소드 선언

- 메소드 선언은 선언부(리턴타입, 메소드이름, 매개변수선언)와 실행 블록으로 구성된다.
- 메소드 선언부를 메소드 시그너처라고도 한다.

> **리턴 타입**
>
- 메소드가 실행 후 리턴하는 값의 타입을 말한다.
- 메소드는 리턴 값이 있을 수도 없을 수도 있다.
- 메소드가 실행 후 결과를 호출한 곳에 넘겨줄 경우에는 리턴 값이 있어야 한다.
- 전자계산기 객체에서 전원을 켜는 powerOn() 메소드와 두 수를 나누는 기능인 divide() 메소드가 있다고 가정
    - divide() 메소드는 나눗셈의 결과를 리턴해야 하지만 powerOn() 메소드는 전원만 켜면 된다.
    - 따라서 powerOn() 메소드는 리턴 값이 없고 divide() 메소드는 리턴 값이 있다.
- 리턴 값이 없는 메소드는 리턴 타입 자리에 void가 와야 하며 리턴 값이 있는 메소드는 리턴 값의 타입이 와야한다.

```java
void powerOn() {
} // 리턴 값이 없는 메소드

double divide(int x, int y) {
} // 리턴 값이 double인 메소드
```

- 리턴 값이 있느냐 없느냐에 따라 메소드를 호출하는 방법이 다르다.

```java
powerOn();
double result = divide(10, 20);
```

- powerOn() 메소드는 리턴 값이 없기 때문에 변수에 저장할 내용 없이 메소드만 호출하면 된다.
- divide() 메소드는 10을 20으로 나눈 후 0.5를 리턴하므로 이것을 저장할 변수가 있어야한다.
  리턴 값을 받기 위해 변수는 메소드의 리턴 타입인 double 타입으로 선언되어야 한다.
- 만약 result 변수를 int 타입으로 선언하면 double 값을 저장할 수 없기 때문에 컴파일 에러가 발생한다.
- 리턴 타입이 있다고 반드시 리턴 값을 변수에 저장하지 않아도 된다. 메소드 실행 후 리턴 값을 다시 사용하지 않는 경우에는 변수에 저장할 필요가 없기 때문이다.

```java
divide(10, 20);
```

> **메소드 이름**
>
- 숫자로 시작하면 안되고, $와 _를 제외한 특수 문자를 사용하지 말아야 한다.
- 관례적으로 메소드명은 소문자로 작성한다.
- 서로 다른 단어가 혼합된 이름이라면 뒤에 오는 단어의 첫머리를 대문자로 작성한다.
- 이 메소드가 어떤 기능을 수행하는지 쉽게 알 수 있도록 기능 이름으로 지어주는 것이 좋다.
- 메소드명의 길이는 프로그램 실행과 무관하기 때문에 너무 짧게 짓지 않도록 한다.

> **매개 변수 선언**
>
- 매개 변수는 메소드를 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용된다.
- 매개 변수도 필요할 수도 필요 없을 수도 있다.
- powerOn() 메소드는 그냥 전원만 켜면 되지만, divide() 메소드는 매개 변수가 두 개 필요하다.

```java
double divide(int x, int y) {
}
```

- divide() 메소드가 int 타입 매개 변수를 가지고 있다면 호출 시 매개 값으로 int 값이나 int 타입으로 변환될 수 있는 값을 넘겨주어야 한다.

```java
double result = divide(10.5, 20.0);
// 매개변수 이렇게 주지 마
```

```java
public class Calculator {

	void powerOn() {
		System.out.println("전원을 켭니다.")
	}

	int plus(int x, int y) {
		int result = x + y;
		return result;
	}
	
	double divide(int x, int y) {
		double result = (double) / (double)y;
		return result;
	}
	
	void poweroff() {
		System.out.println("전원을 끕니다");
	}
```

```java
public class CalculatorExample {
	public static void main(String[] args) {
		Calculator myCalc = new Calculator ();
		myCalc.powerOn();
		
		int result1 = myCalc.plus(5, 6);
		System.out printIn("resulti: " + result1);

		byte x = 10;
		byte y = 4;
		double result2 = myCalc.divide(x, y);
		System.out printIn("result2: " + result2);
		
		myCalc.poweroff();
	}
}
```

> **매개 변수의 수를 모를 경우**
>
- 메소드의 매개 변수는 개수가 이미 정해져 있는 것이 일반적이지만, 경우에 따라 메소드를 선언할 때 매개 변수의 개수를 알 수 없는 경우가 있다.
- 여러 개의 수를 모두 합산하는 메소드를 선언해야 할 때, 몇 개의 매개 변수가 입력될지 알 수 없기 때문에 매개 변수의 개수를 결정할 수 없다.
- 이를 해결 하기 위해서 다음과 같이 매개 변수를 배열 타입으로 선언할 수 있다.

```java
int sum1(int[] values) {
}
```

- sum1 메소드 호출 시 배열을 넘겨줌으로써 배열의 항목 값들을 모두 전달 할 수 있다.

```java
int[] values = {1, 2, 3};
int result = sum1(values);
int result = sum1(new int[] {1, 2, 3, 4, 5});)
```

- 매개 변수를 배열 타입으로 선언하면, 메소드를 호출하기 전에 배열을 생성해야하는 불편한 점이 있다.
- 그래서 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다.
- 다음과 같이 sum2() 메소드의 매개 변수를 “…”를 사용해서 선언하게 되면, 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.

```java
int sum2(int ... values) {
}
```

- “…”로 선언된 매개 변수의 값은 다음과 같이 메소드 호출 시 리스트로 나열해주면 된다.

```java

int result = sum2(1, 2, 3);
int result = sumg2(1, 2, 3, 4, 5);
```

- return문을 사용할 때 주의할 점은 return문 이후에 실행문이 오면 “Unreachable code”라는 컴파일 오류가 발생한다. return문 이후의 실행문은 실행되지 않기 때문이다.

> **리턴값이 없는 메소드(void)**
>
- void로 선언된 리턴값이 없는 메소드에서도 return문을 사용할 수 있다.
- 다음과 같이 return문을 사용하면 메소드 실행을 강제 종료시킨다.

```java
return;
```

- 다음은 gas 값이 0보다 클 경우 계속해서 while문을 실행하고, 0일 경우 return문을 실행해서 run() 메소드를 즉시 종료한다.
- 이 예제에서는 return문 대신 break문을 사용할 수 있다.
- 만약 while문 뒤에 실행문이 추가적으로 더 있을 경우, break문을 반드시 사용해야 한다.
- return문은 즉시 메소드를 종료시키기 때문이다.

```java
void run() {
	while(true) {
			if(gas > 0) {
				System.out.println("달립니다. (gas잔량:)" + gas + ")");
				gas -= 1;
			} else {
				System.out.println("멈춥니다.(gas잔량:"+ gas + ")");
				return;
			}
		}
	}		
```

---

### 6.83 메소드 호출

- 메소드는 클래스 내•외부의 호출에 의해 실행된다.
- 클래스 내부의 다른 메소드에서 호출할 경우에는 단순한 메소드 이름으로 호출하면 된다.
- 클래스 외부에서 호출할 경우에는 우선 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해서 메소드를 호출해야한다.(객체가 존재해야 메소드도 존재하기 때문)

> **객체 내부에서 호출**
>
- 클래스 내부에서 다른 메소드를 호출할 경우에는 다음과 같은 형태로 작성하면 된다.
- 메소드가 매개변수를 가지고 있을 때에는 매개 변수의 타입과 수에 맞게 매개값을 제공한다.

```java
메소드( 매개값, ...);
```

- 예를 들어 method2() 메소드에서 method1() 메소드를 호출하려면 다음과 같이 작성하면 된다.

```java
public class ClassName {
	void method1(String p1, int p2) {
		//실행문
	}
	
	void method2() {
		method1("홍길동", 100);
	}
}
```

- 메소드가 리턴값이 없거나, 있어도 받고 싶지 않을 경우 위와 같이 모두 호출이 가능
- 리턴값이 메소드를 호출하고 리턴 값을 받고 싶다면 다음과 같이 변수를 선언하고 대입하면 된다.

```java
타입 변수 = 메소드(매개값, ...);
```

- 변수 타입은 메소드 리턴 타입과 동일하거나, 타입 변환이 될 수 있어야한다.
- 예를 들어 int 타입은 double 타입으로 자동 변환되기 때문에 int 리턴 값은 double 변수에 대입할 수 있다.

> **객체 외부에서 호출**
>
- 외부 클래스에서 메소드를 호출하려면 우선 다음과 같이 클래스로부터 객체를 생성해야 한다.
- 메소드는 객체에 소속된 멤버이므로 객체가 존재하지 않으면 메소드도 존재하지 않기 때문이다.

```java
클래스 참조변수 = new 클래스(매개값, ...);
```

- 객체가 생성되면 참조 변수와 함께 도트(.) 연산자를 사용해서 메소드를 호출할 수 있다.
- 도트 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나, 메소드에 접근할 때 사용된다.

```java
참조변수.메소드(매개값, ...);
```

---

### 6.8.4 메소드 오버로딩

- 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩이라고 한다.
- 오버로딩의 사전적 의미는 많이 싣는 것을 뜻한다.
- 하나의 메소드 이름으로 여러 기능을 담는다 하여 붙여진 이름이라 생각할 수 있다. 메소드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야한다.
- 메소드 오버로딩이 필요한 이유는 매개 값을 다양하게 받아 처리할 수 있도록 하기 위해서이다.

```java
int plus(int x, int y) {
	int result = x + y;
	return result;
}
```

- plus() 메소드를 호출하기 위해서는 두 개의 int 매개값이 필요하다.
- 하지만 int 타입이 아닌 double 타입의 값을 덧셈하기 위해서는 plus() 메소드를 호출할 수 없다.
- 이를 해결하기 위해 매개 변수가 double 타입으로 선언된 plus() 메소드를 하나 더 선언한다.

```java
double plus(double x, double y) {
	double result = x + y;
	return result;
```

- 오버로딩된 메소드를 호출할 경우 JVM은 매개 값의 타입을 보고 메소드를 선택한다.

```java
int x = 10;
double y = 20.3;
plus(x, y);
```

- 위 코드를 실행하면 컴파일 오류가 날까? 아니다.
- plus(double x, double y)메소드가 실행된다.
- 자바 가상 기계는 일차적으로 매개 변수 타입을 보지만, 매개 변수의 타입이 일치하지 않을 경우, 자동 타입 변환이 가능한지를 검사한다. int 타입이 double 타입으로 변환이 가능하기 때문에 최종적으로 plus(double x, double y) 메소드가 선택된다.
- 매개 변수의 이름만 바꾸거나 리턴 타입만 다른 것은 JVM이 메소드를 선택할 때 아무런 도움을 주지 못하기 때문에 오버로딩이라고 볼 수 없다.

---

### 6.9 인스턴스 멤버와 this

- 인스턴스 멤버란 객체를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.
- 인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이 사용할 수 없다.

```java
public class Car {
	//필드
	int gas;
	
	//메소드
	void setSpeed(int speed) {
	...
	}
}
```

- 다른 클래스에서 위의 필드와 메소드를 사용하기 위해서는 아래와 같이 해야한다.

```java
Car myCar = new Car();
myCar.gas = 10;
myCar.setSpeed(60);

Car yourCar = new Car();
yourCar.gas = 20;
yourCar.setSpeed(80);
```

- 객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다.
- 우리가 자신을 “나”라고 하듯, 객체는 자신을 “this”라고 한다.
- 따라서 this.model은 자신이 가지고 있는 model 필드라는 뜻이다.
- this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.

```java
Car(String model) {
	this.model = model;
}
void setModel(String model) {
	this.model = model;
	}
```

---

### 6.10 정적 멤버와 static

- 정적은 ‘고정된’이란 의미를 가지고 있다.
- 정적 멤버는 클래스에 고정된 멤버로 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.
- 각각 정적 필드, 정적 메소드라고 부른다.
- 정적 멤버는 객체에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.

---

### 6.10.1 정적 멤버 선언

- 정적 필드와 정적 메소드를 선언하는 방법은 필드와 메소드 선언 시 static 키워드를 추가적으로 붙이면 된다.

```java
public class 클래스 {
	//정적 필드
	static 타입 필드 [= 초기값];
	
	//정적 메소드
	static 리턴 타입 메소드(매개변수선언, ...) {
	}
```

- 필드 선언 시 객체마다 가지고 있어야 할 데이터는 인스턴스 필드, 객체마다 가지고 있지 않아도 되는 공용적인 데이터는 정적 필드로 선언하는 것이 좋다.
- 메소드의 경우 인스턴스 필드를 이용해서 실행해야 한다면 인스턴스 메소드로 선언, 그렇지 않다면 정적 메소드로 선언한다.

---

### 6.10.2 정적 멤버 사용

- 클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있는데, 클래스 이름과 함께 도트(.) 연산자로 접근한다.

```java
클래스.필드;
클래스.메소드(매개값, ...);
```

- 예를 들어 아래 클래스가 있을 때

```java
public class Calculator {
	static double pi = 3.14159;
	static int plus(int x, int y) {...}
	static int minus(int x, int y) {...}
}
```

- 정적 필드 pi와 정적 메소드 plus(), minus()는 다음과 같이 사용할 수 있다.

```java
double result1 = 10 * 10 * Calculator.pi;
int result2 = Calculator.plus(10, 5);
int result3 = Calculator.minus(10, 5);
```

- 정적 필드와 정적 메소드는 원칙적으로 클래스 이름으로 접근해야 하지만 다음과 같이 객체 참조 변수로도 접근이 가능하다.

```java
Calculator myCalcu = new Calculator();
double result1 = 10 * 10 * myCalcu.pi;
int result2 = myCalcu.plus(10, 5);
int result3 = myCalcu.minus(10, 5);
```

---

### 6.10.3 정적 초기화 블록

- 정적 필드는 다음과 같이 필드 선언과 동시에 초기값을 주는 것이 보통이다.

```java
static double pi = 3.14159;
```

- 인스턴스 필드는 생성자에서 초기화하지만, 정적 필드는 객체 생성 없이도 사용해야 하므로 생성자에서 초기화 작업을 할 수 없다. 생성자는 객체 생성 시에만 실행되기 때문이다.
- 자바는 정적 필드의 복잡한 초기화 작업을 위해서 정적 블록을 제공한다.

```java
static {
...
}
```

- 정적 블록은 클래스 내부에 여러 개가 선언되어도 상관없다.
- 아래 예제를 보면 Television은 세 개의 정적 필드를 가지고 있는데, company와 model은 선언 시 초기 값을 주었고 info는 초기화하지 않았다.
- info 필드는 정적 블록에서 company와 model 필드 값을 서로 연결해서 초기값으로 설정한다.

```java
public class Television {
	static String company = "Samsung";
	static String model = "LCD";
	static String info;
	
	static {
		info = company + "-" + model;
	}
}
```

---

### 6.10.4 정적 메소드와 블록 선언 시 주의할 점

- 객체가 없어도 실행된다는 특징 때문에, 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다.
- 객체 자신의 참조인 this 키워드 사용 또한 불가능하다.
- 따라서 다음 코드는 컴파일 오류가 발생한다.

```java
public class ClassName {
	//인스턴스 필드와 메소드
	int field;
	void mehod1() {
	...
	}
	
	//정적 필드와 메소드
	static int field2;
	static void method2() {
	...
	}
	
	//정적 블록
	static {
		field1 = 10;  //컴파일 에러
		mehod1();     //컴파일 에러
		field2 = 10;
		method2();
	}
	
	//정적 메소드
	static void Method3 {
		this.field1 = 10; //컴파일 에러
		this.method1();   //컴파일 에러
		field2 = 10;
		method2();
	}
}
	
```

- 정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 다음과 같이 객체를 먼저 생성하고 참조 변수로 접근해야한다.

```java
static void Method3() {
	ClassName obj = new ClassName();
	obj.field1 = 10;
	obf.method1();
}
```

- main() 메소드도 정적(static) 메소드이므로 객체 생성 없이 인스턴스 필드와 메소드를 바로 사용할 수 없다.

---

### 싱글톤(Singleton)

- 가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다.
- 단 하나만 생성된다고 해서 이 객체를 싱글톤이라고 한다.
- 싱글톤을 만들기 위해서는 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다.
- 생성자를 호출한 만큼 객체가 생성되기 때문이다.
- 생성자를 외부에서 호출할 수 없도록 하려면 생성자 앞에 private 접근 제한자를 붙여주면 된다.
- 그리고나서 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화 한다.
- 클래스 내부에서는 new 연산자로 생성자 호출이 가능하다.
- 정적 필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막는다.
- 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.

```java
public class 클래스 {
	//정적 필드
	private static 클래스 singleton = new 클래스();
	
	//생성자
	private 클래스() {}
	
	//정적 메소드
	static 클래스 getInstance() {
		return singleton;
	}
}
```

- 외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드를 호출하는 방법이다.
- getInstance() 메소드는 단 하나의 객체만 리턴하기 때문에 아래 코드에서 변수1과 변수2는 동일한 객체를 참조한다.

```java
클래스 변수1 = 클래스.getInstance();
클래스 변수2 = 클래스.getInstance();
```

---

### 6.11 final 필드와 상수

### 6.11.1 final 필드

- final의 의미는 최종적이라는 뜻을 가지고 있다.
- final 필드는 최종적인 필드라는 뜻인데 무슨 말일까?
- final 필드는 초기 값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다는 것이다.
- final 필드 선언 방법

```java
final 타입 필드 [= 초기값];
```

- final 필드의 초기값을 줄 수 있는 방법 중 첫 번째는 필드 선언 시 주는 방법이고 두 번째 방법은 생성자에서 주는 방법이다.
- 단순 값이라면 필드 선언 시에 주는 것이 제일 간단하다.
- 복잡한 초기화  코드가 필요하거나 객체 생성 시에 외부 데이터로 초기화해야 한다면 생성자에서 초기값을 지정해야한다.
- 생성자는 final 필드의 최종 초기화를 마쳐야 하는데, 만약 초기화되지 않은 final 필드를 그대로 남겨두면 컴파일 에러가 발생한다.
- 아래 예제는 주민등록번호 필드는 한 번 값이 저장되면 변경할 수 없도록 final 필드로 선언했다. 하지만 주민등록번호는 Person 객체가 생성될 때 부여되므로 Person 클래스 설계 시 초기값을 미리 줄 수 없다. 그래서 생성자 매개값으로 주민등록번호를 받아 초기값으로 지정해주었다. 반면 nation은 항상 고정된 값을 갖기 때문에 필드 선언 시 초기값으로 “Korea”를 주었다.

```java
public class Person {
	final String nation = "Korea";
	final String ssn;
	String name;
	
	public Person(String ssn, String name) {
		this.ssn = ssn;
		this.name = name;
	}
}
```

```java
public class PersonExample {
	public static void main(String[] args) {
		Person p1 = new Person("123456-1234567", "계백");
		
		System.out.println(p1.nation);
		System.out.println(p1.ssn);
		System.out.println(p1.name);
		
		//p1.nation ="usa";            //final 필드는 값 수정 불가
		//p1.ssn = "654321-7654321";   //final 필드는 값 수정 불가
		p1.name = "을지문덕";
}
```

---

### 6.11.2 상수(static final)

- 일반적으로 불변의 값을 상수라고 부른다.
- 불변의 값은 수학에서 사용되는 원주율 파이나, 지구의 무게 및 둘레 등이 해당된다.
- 불변의 값을 저장하는 필드를 자바에서는 상수라고 한다.
- final 필드는 한 번 초기화되면 수정할 수 없는 필드라고 했으니 final 필드를 상수라고 불러도 되지 않는가?
- final 필드를 상수라고 하지 않는다. 왜냐하면 불변의 값은 객체마다 저장할 필요가 없는 공용성을 띠고 있고, 여러 가지 값으로 초기화될 수 없기 때문이다.
- final필드는 객체마다 저장되고, 생성자의 매개값을 통해 여러 가지 값을 가질 수 있기 때문에 상수가 될 수 없다.
- 상수는 static이면서 final이어야 한다. static final 필드는 객체마다 저장되지 않고, 클래스에만 포함 된다.
- 또한 한 번 초기값이 저장되면 변경할 수 없다.

```java
static final 타입 상수 [= 초기값];
```

- 초기 값이 복잡한 초기화일 경우 정적 블록에서도 할 수 있다.

```java
static final 타입 상수;
static {
	상수 = 초기값;
}
```

- 상수 이름은 모두 대문자로 작성하는 것이 관례이다.
- 서로 다른 단어가 혼합된 이름이라면 언더바로 단어들을 연결해준다.

```java
public class Earth {
	static final double EARTH_RADIUS = 6400;
	static final double EARTH_SURFACE_AREA;
	
	static {
		EARTH_SURFACE_AREA = 4 * Math.PI * EARTH_RADIUS * EARTH_RADIUS;
	}
}
```

```java
public class EarthExample {
	public static void main(String[] args) {
		System.out.println("지구의 반지름: " + Earth.EARTH_RADIUS+ "km");
		System.out.println("지구 표면적: " + Earth.EARTH_SURFACE_AREA + " km^2");
	}
}
```

---

### 6.12 패키지

- 클래스를 체계적으로 관리하기 위해 패키지를 사용한다.
- 단순히 파일 시스템의 폴더 기능만 하는 것이 아니라 클래스의 일부분이다.
- 클래스를 유일하게 만들어주는 식별자 역할을 한다.
- 클래스 이름이 동일하더라도 패키지가 다르면 다른 클래스로 인식한다.
- 패키지가 중요한 이유는 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스는 사용할 수 없기 때문이다.
- 예를 들어 Car 클래스가 com.mycompany  패키지에 소속되어 있을 경우, 파일 시스템 com\yourcompany 폴더에 Car.class를 저장하면 Car 클래스를 사용할 수 없다.
- 클래스를 이동할 경우에는 패키지 전체를 이동시켜야 한다.

---

### 6.12.1 패키지 선언

- 패키지는 클래스를 컴파일 하는 과정에서 자동적으로 생성되는 폴더이다.
- 컴파일러는 클래스에 포함되어 있는 패키지 선언을 보고 ,파일 시스템의 폴더로 자동 생성시킨다.

```java
package 상위패키지.하위패키지;

public class ClassName { ...}
```

- 패키지 이름 규칙
    - 숫자로 시작하면 안되고, _, $를 제외한 특수 문자를 사용해서는 안 된다.
    - java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안된다.
    - 모두 소문자로 작성하는 것이 관례이다.
- 회사들 간에 패키지가 중복되지 않도록 흔히 회사의 도메인 이름을 패키지로 만든다.
- 도메인 이름을 역순으로 패키지 이름을 지어주는데, 그 이유는 포괄적인 이름이 상위 패키지가 되도록 하기 위해서이다.
- 마지막에는 프로젝트 이름을 붙여주는 것이 관례이다.

```java
com.samsung.projectname
com.lg.projectname
```

---

### 6.12.4 import 문

- 같은 패키지에 속하는 클래스들은 아무런 조건 없이 다른 클래스를 사용할 수 있지만 다른 패키지에 속하는 클래스를 사용하려면 두 가지 방법 중 하나를 선택해야 한다.
- 첫 번째 방법은 패키지와 클래스를 모두 기술하는 것이다.
- 다음은 com.hankook 패키지에 소속된 Tire 클래스를 이용해서 필드를 선언하고 객체를 생성한 것이다.

```java
package com.mycompany;

public class Car {
	com.hankook.Tire tire = new com.hankook.Tire();
}
```

- 패키지 이름이 길어지면 코드를 난잡하게 보이게 할 수 있다.
- 따라서 두 번째 방법인 import문을 주로 사용한다.
- 사용하고자 하는 패키지를 import문으로 선언하고, 클래스를 사용할 때에는 패키지를 생략하는 것이다.

```java
package com.mycompany;

import com.hankook.Tire;

public class Car {
	Tire tire = new Tire();
}
```

- import문이 작성되는 위치는 패키지 선언과 클래스 선언 사이다.
- 패키지에 포함된 다수의 클래스를 사용해야 한다면 클래스별로 import문을 작성할 필요 없이 클래스 명을 생략하고 *를 사용해서 import 문을 한 번만 작성하면 된다.
- 패키지 이름 전체를 기술하는 방법이 꼭 필요한 경우가 있는데, 서로 다른 패키지에 동일한 클래스 이름이 존재하고, 두 패키지 모두 import 되어 있는 경우이다.
- 자바 컴파일러가 어떤 클래스를 로딩할지 결정할 수 없기 때문에 컴파일 에러가 발생하기 때문이다.

---

### 6.13 접근 제한자

- main() 메소드를 가지지 않는 대부분의 클래스는 외부 클래스에서 이용할 목적으로 설계된 라이브러리 클래스이다.
- 라이브러리 클래스를 설계할 때에는 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버로 구분해서 필드, 생성자, 메소드를 설계하는 것이 바람직하다.
- 객체 생성을 막기 위해 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해 해당 필드에 접근하지 못하도록 막아야한다.
- 그리고 특정 메소드를 호출할 수 없도록 제한할 필요가 있는데, 자바는 이러한 기능을 구현하기 위해 접근 제한자를 제공하고 잇다.
- 접근 제한자의 종류에는 public, protected, default, private 네 가지가 있다.
- public은 단어의 뜻 그대로, 공개한다는 의미를 가진다. 외부 클래스가 자유롭게 사용할 수 있는 공개 멤버를 만든다.
- protected는 같은 패키지 또는 자식 클래스에서 사용할 수 있는 멤버를 만든다.
- private은 단어 뜻 그대로 개인적인 것이라 외부에 노출되지 않는 멤버를 만든다.
- 위 세 가지 접근 제한자가 적용되지 않은 default는 접근 제한을 가진다. 같은 패키지에 소속된 클래스에서만 사용할 수 있는 멤버를 만든다.

---

### 6.13.1 클래스의 접근 제한

- 클래스에 적용할 수 있는 접근 제한은 public 과 default 두 가지이다.

```java
//default 접근 제한
class 클래스 {...}

//public 접근 제한
public class 클래스 {...}
```

> **default 접근 제한**
>
- 클래스 선언 시 public을 생략했다면 클래스는 default 접근 제한을 가진다.
- 클래스가 default 접근 제한을 가지게 되면 같은 패키지에서는 제한 없이 사용이 가능하지만 다른 패키지에서는 사용할 수 없도록 제한된다.

> **public 접근 제한**
>
- 같은 패키지뿐만 아니라 다른 패키지에서도 아무런 제한 없이 사용이 가능하다.
- 인터넷으로 배포되는 라이브러리 클래스들도 모두 public 접근 제한을 가지고 있다.

---

### 6.13.2 생성자의 접근 제한

- 객체를 생성하기 위해서는 new 연산자로 생성자를 호출해야 한다.
- 하지만 생성자를 어디에서나 호출할 수 있는 것은 아니다.
- 생성자가 어떤 접근 제한을 갖느냐에 따라 호출 가능 여부가 결정된다.
- 생성자는 public , protected, default, private 접근 제한을 가질 수 있다.

```java
public class ClassName {
	public ClassName(...) {...}
	
	protected ClassName(...){...}
	
	ClassName(...) {...}
	
	private ClassName(...) {...}
}
```

- 클래스에 생성자를 선언하지 않으면 컴파일러에 의해 자동적으로 기본 생성자가 추가된다.
- 자동으로 생성되는 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일하다.

---

### 6.14 Getter와 Setter 메소드

- 일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다.
- 그 이유는 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨질 수 있기 때문이다.
- 예를 들어 자동차의 속도는 음수가 될 수 없는데, 외부에서 음수로 변경하면 객체의 무결성이 깨진다.
- 이러한 문제점을 해결하기 위해 객체 지향 프로그래밍에서는 메소드를 통해서 데이터를 변경하는 방법을 선호한다.
- 데이터는 외부에서 접근하지 못하도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다.
- 이러한 역할을 하는 메소드가 Setter이다.
- 예를 들어 자동차의 속도를 setSpeed() 메소드로 변경할 경우 다음과 같이 검증 코드를 작성할 수 있다.

```java
void setSpeed(double speed) {
	if(speed < 0) {
		this.speed = 0;
		return;
	} else {
		this.speed = speed;
	}
}
```

- 외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는 것이 좋다.
- 객체 외부에서 객체의 필드값을 사용하기에 부적절한 경우도 있다. 이런 경우에는 메소드로 필드값을 가공한 후 외부로 전달하면 된다.
- 이러한 역할을 하는 메소드가 바로 Getter이다.
- 예를 들어 자동차의 속도를 마일에서 KM 단위로 환산해서 외부로 리턴해주는 getSpeed() 메소드를 다음과 같이 작성할 수 있다.

```java
double getSpeed() {
	double km = speed*1.6;
	return km;
}
```

- 클래스를 선언할 때 가능하면 필드를 private으로 선언해서 외부로부터 보호하고, 필드에 대한 Setter와 Getter 메소드를 작성해서 필드값을 안전하게 변경/사용하는 것이 좋다.
- 필드 타입이 boolean일 경우에는 Getter는 is로 시작하는 것이 관례이다.

```java
private boolean stop;

//Getter
public boolean isStop() {
	return stop;
}
//Setter
public void setStop(boolean stop) {
	this.stop = stop;
}
```

- 만약 외부에서 필드값을 읽을 수만 있고 변경하지 못하도록 하려면(읽기 전용) Getter 메소드만 선언해도 좋고, 아니면 Setter 메소드를 private 접근 제한을 갖도록 선언해도 좋다.

---

### 6.15 어노테이션

- 어노테이션은 메타데이터라고 볼 수 있다.
- 메타데이터란 애플리케이션이 처리해야 할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다.
- 어노테이션 용도
    - 컴파일러에게  코드 문법 에러를 체크하도록 정보를 제공
    - 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
    - 실행 시 특정 기능을 실행하도록 정보 제공
- 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공하는 대표적인 예는 @Override 어노테이션이다.
- @Override는 메소드 선언 시 사용하는데, 메소드가 오버라이드(재정의)된 것임을 컴파일러에게 알려주어 컴파일러가 오버라이드 검사를 하도록 해준다.
- 정확히 오버라이드가 되지 않았다면 컴파일러는 에러를 발생시킨다.
- 어노테이션은 빌드 시 자동으로 XML 설정 파일을 생성하거나, 배포를 위해 JAR 압축 파일을 생성하는데에도 사용된다.

---

### 6.15.1 어노테이션 타입 정의와 적용

- 어노테이션 타입을 정의하는 방법은 인터페이스를 정의하는 것과 유사하다. 다음과 같이 @interface를 사용해서 어노테이션을 정의하며, 그 뒤에 사용할 어노테이션 이름이 온다.

```java
public @interface AnnotationName {
}
```

- 이렇게 정의한 어노테이션은 코드에서 다음과 같이 사용한다.

```java
@AnnotationName
```

- 어노테이션은 엘리먼트를 멤버로 가질 수 있는데 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.
- 엘리먼트의 타입으로는 int나 double과 같은 기본 데이터 타입이나, String, 열거 타입, Class 타입, 그리고 이들의 배열 타입을 사용할 수 있다.
- 엘리먼트의 이름 뒤에는 메소드를 작성하는 것처럼 ()를 붙여야 한다.

```java
public @interface AnnotationName {
	String elementName1();
	int elementName2() default 5;
}
```

이렇게 정의한 어노테이션을 코드에서 적용할 때에는 다음과 같이 기술한다.

```java
@AnnotationName(elementName1 = "값", elementName2=3);
또는
@AnnotationName(elementName1="값");
```

- elementName2는 디폴트 값이 있기 때문에 생략가능

---

### 6.15.2 어노테이션  적용 대상

- 어노테이션을 적용할 수 있는 대상은 java.lang.annotation.ElementType 열거상수 목록이다.
- 어노테이션의 적용 대상을 지정할 때는 @Target 을 사용한다. @Target의 기본 엘리먼트인 value는 ElementType 배열을 값으로 가진다. 이것은 어노테이션이 적용될 대상을 복수 개로 지정하기 위해서이다.

---

### 6.15.3 어노테이션 유지 정책

- 사용 내용에 따라 @AnnotationName을 어느 범위까지 유지할 것인지 지정해야 한다.
- ex) 소스까지(SOURCE), 컴파일된 클래스까지(CLASS), 런타임 시까지(RUNTIME) // RetentionPolicy 열거상수로 정의되어 있음.
- 리플렉션(Reflection)이란 런타임 시에 클래스의 메타 정보를 얻는 기능을 말한다.
- 보통 어노테이션은 런타임 시점에 사용하기 위한 용도로 만들어진다.

---

### 6.15.4 런타임 시 어노테이션 정보 사용하기

- 런타임 시 어노테이션이 적용되었는지 확인하고 엘리먼트 값을 이용해서 특정 작업을 수행하는 방법
    - 어노테이션 자체는 아무런 동작을 가지지 않는 단지 표식이지만, 리플렉션을 이용해서 어노테이션의 적용 여부와 엘리먼트 값을 읽고 적절히 처리할 수 있다.