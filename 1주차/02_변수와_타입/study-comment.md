# 2장 변수와 타입

# 2.1 변수

## 2.1.1 변수란?

- 변수란 하나의 값을 저장할 수 있는 메모리 공간이다.
- 다양한 타입의 값을 저장할 수 없고, 한 가지 타입의 값만 저장할 수 있다.

## 2.1.2 변수의 선언

- 변수 선언은 어떤 타입의 데이터를 저장하고 변수 이름이 무엇인지 결정한다.

<aside>
💡 int age;                //정수(int) 값을 저장할 수 있는 age 변수 선언
double value;      //실수(double)값을 저장할 수 있는 value 변수 선언

</aside>

- 같은 타입의 변수는 콤마를 이용하여 한꺼번에 선언할 수도 있다.

<aside>
💡 int x,y,z ;

</aside>

변수명

| 작성 규칙 | 예 |
| --- | --- |
| 첫 번째 글자는 문자이거나 ‘$’, ‘_’ 이어야 하고 숫자로 시작할 수 없다 | 가능: price, $price, _companyName 안됨: 1v, @speed, $#value |
| 영어 대소문자가 구분된다. (필수) | firstname과 firstName은 다른 변수 |
| 첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 한다. (관례) | maxSpeed, firstnAME, CarBodyColor |
| 문자 수(길이)의 제한은 없다. |  |
| 자바 예약어는 사용할 수 없다.(필수) |  |

- 개발자는 변수 이름을 보고, 이 변수가 어떤 값을 저장하고 있는지 쉽게 알 수 있도록 의미 있는 변수 이름을 지어주는 것이 좋다.
- 명명 규칙과 관련된 개발자들의 관례를 지키고 한글을 포함하지 않는 것이 좋다.

## 2.1.3 변수의 사용

### 변수값 저장

- 변수에 값을 저장할 때에는 대입 연산자(=)를 사용한다.
- 자바 언어에서는 우측의 값을 좌측 변수에 저장한다는 의미를 가진다.
- 변수를 선언하고 처음 값을 저장하는 경우 초기값이라고 하고 초기값을 주는 행위를 변수의 초기화라고 한다.

<aside>
💡 int score               //변수 선언
score = 90;          // 값 저장

int score = 90     //초기값은 변수 선언함과 동시에 줄 수도 있다.

</aside>

- 변수의 초기값은 코드에서 직접 입력하는 경우가 많은데 소스 코드 내에서 직접 입력된 값을 리터럴이라고 부른다.
    - 리터를은 상수와 같은 의미지만 프로그램에서 상수는 “값을 한 번 저장하면 변경할 수 없는 변수로 정의하기에 구분을 위해 “리터럴”이라는 용어를 사용한다.
- 리터럴은 정해진 표기법대로 작성되어야한다.

> 정수 리터럴
>
- 소수점이 없는 정수 리터럴은 10진수로 간주한다
    - 0,  75,  -100
- 0으로 시작되는 리터럴은 8진수로 간주한다.
    - 02, -04
- 0x 또는 0X로 시작하고 0~9 숫자나 A,B,C,D,E,F 또는 a,b,c,d,e,f로 구성된 리터럴은 16진수로 간주한다
    - 0x5, 0xA, 0xB3, 0xAc08
- 정수 리터럴을 저장할 수 있는 타입은 byte, char, short, int long과 같이 5개가 있다

> 실수 리터럴
>
- 소수점이 있는 리터럴은 10진수 실수로 간주한다.
    - 0.25, -3.14
- 대문자 E 또는 소문자 e가 있는 리터럴은 10진수 지수와 가수로 간주한다.
    - 5E7 ,   0.12E-5
- 실수 리터럴을 저장할 수 있는 타입은 float, double이 있다.

> 문자 리터럴
>
- 작은 따옴표 ‘로 묶은 텍스트는 하나의 문자 리터럴로 간주한다.
    - ‘A’, ‘한’, ‘\t’ ‘\n’
- 역슬래쉬(\) 가 붙은 문자 리터럴은 이스케이프문자로고도 한다

| 이스케이프 문자 | 용도 |
| --- | --- |
| \t | 수평 탭 |
| \n | 줄 바꿈 |
| \r | fㅣ턴 |
| \” | "(큰따옴표) |
| \’ | '(작은 따옴표) |
| \\ | \ |
| \u16진수 | 16진수에 해당하는 유니코드 |
- 문자 리터럴을 저장할 수 있는 타입은 char 하나뿐이다.

> 문자열 리터럴
>
- 큰 따옴표(”)로 묶은 텍스트는 문자열 리터럴로 간주한다.
- 큰따옴표 안에는 텍스트가 없어도 문자열 리터럴로 간주된다.
- 문자열 내부에서도 이스케이프 문자를 사용할 수 있다.
    - “대한민국”
    - “탭 만큼 이동 \t 합니다.”
    - “한 줄 내려 쓰기 \n 합니다.”

> 논리 리터럴
>
- true와 false는 논리 리터럴로 간주한다.
    - true, false
- 논리 리터럴을 저장할 수 있는 타입은 boolean 하나뿐이다.

### 변수값 읽기

- 변수는 초기화가 되어야 읽을 수 있고 초기화가 되지 않은 변수는 읽을 수가 없다.
    - int value   //변수 value 선언 (초기화 안됨)
    - int result = value + 10 // 변수 value 값을 읽고 10을 더한 결과값을 변수 result에 저장
- 변수 value가 선언되었지만 초기화가 되지 않았기 때문에 산술 연산식 value +!0에서 사용할 수 없고 컴파일 에러가 발생한다.

<aside>
💡 int value = 30; //변수 value가 30으로 초기화 됨
int result = value + 10 //변수 value 값을 읽고 10을 더한 결과값을(40)을 변수 result에 저장

</aside>

## 2.1.4 변수의 사용 범위

- 변수는 중괄호 {} 블록 내에서 선언되고 사용된다. 중괄호 블록을 사용하는 곳은 클래스,생성자,메소드지만 먼저 메소드 블록 내에 존재한다고 생각하자.
- 메소드 블록 내에서 선언된 변수를 특히 로컬 변수라고 부른다.
- 로컬 변수는 메소드 실행이 끝나면 메모리에서 자동으로 없어진다.
- 변수는 메소드 블록 내 어디서든 선언할 수 있지만 변수 사용은 제한이 따른다.

<aside>
💡 변수는 선언된 블록 내에서만 사용이 가능하다.

</aside>

- 메소드 블록 내에서도 여러가지 중괄호{} 블록들이 있을수 있다.
- 조건문에 해당하는 if(){}, 반복문에 해당하는 for(){}, while(){}등이 중괄호를 가질 수 있다.
- 이러한 if,for,while을 제어문이라고 하는데 제어문 블록에서 선언된 변수는 해당 제어문 블록 내에서만 사용이 가능하다.
- 따라서 변수를 선언할 떄는 변수가 어떤 범위에서 사용될 것인지 생각하고 선언 위치를 결정해야 한다.
    - 메소드 블록에서 어떤 위치에서건 사용할 수 있도록 하려면 메소드 블록 첫머리에 선언!
    - 제어문 내잠깐 사용되는 변수라면 제어문 내에서 선언!

<aside>
💡 public class VariableScopeExample {
    public static void main(String[] args) {
      int v1 = 15;
      if(v1>10) {
          int v2 = v1 - 10;
      }
      int v3 = v1 + v2 + 5;     //v2 변수를 사용할 수 없기 때문에 컴파일 에러가 생김
}
}

</aside>

- 7라인에서 컴파일 에러가 발생하는데 v2가 선언된 곳은 if 블록 내부인 5라인이므로 if 블록 바깥쪽인 7라인에서는 사용할 수 없다.
- 에러 메시지는 v2 cannot be resolved to a variable이라고 출력되는데 이것은 변수 v2를 해석할 수 없다는 뜻이다.
- v1은 3라인에서 선언되었기 때문에 main() 메소드 내부 어디에서든 사용이 가능하다.

## 2.2 데이터 타입

- 모든 변수에는 타입이 있으며 타입에 따라 저장할 수 있는 값 종류와 범위가 달라진다.
- 변수를 선언할 때 주어진 타입은 변수를 사용하는 도중에 변경할 수 없다.

### 2.2.1 기본(원시: primitive) 타입

- 기본(원시) 타입이란 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입을 말한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/de4e3c9d-6400-429e-87f8-eceb13c4cb90/0e02fb16-6bb5-4976-9e66-30975156744a/Untitled.png)

### 2.2.2 정수 타입 (byte, char, short, int, long)

- 정수 타입에는 모두 다섯 개의 타입이 있으며 저장할 수 있는 값의 범위가 서로 다르다.
- 자바는 기본적으로 정수 연산 int 타입으로 수행한다.

### byte 타입

- byte 타입은 색상 정보 및 파일 또는 이미지 등의 이진 데이터를 처리할 때 주로 사용된다.
- byte 타입 정수 탕비 중에서 가장 작은 범위의 수를 저장하고 -128 ~ 127 값의 범위를 가진다. (0 포함)
- byte 타입은 1byte, 즉 8bit 크기를 가지므로 0과 1이 8개로 구성된 이진수로 표현이 가능하다.
- 최상위 비트는 정수의 값의 부호를 결정한다
    - 최상위 비트가 0이면 양의 정수, 1이면 음의 정수를 뜻하다.
- 실행 중에 저장할 수 있는 값의 범위를 초과하면 최소값부터 다시 반복 저장데 되는데 byte일 경우 127(최대값)을 넘으면 다시 -128부터 시작하고 엉터리 값이 변수에 저장되는데 이러한 값을 쓰레기 값이라고 한다.
- 개발자는 쓰레기 값이 생기지 않도록 주의해야한다.

### char 타입

- 자바는 모든 문자를 유니코드로 처리한다.
- 유니코드는 하나의 문자에 대해 하나의 코드값을 부여하기 때문에 영문 ‘A’ 및 한글 ‘가’도 하나의 코드값을 가진다.
- 유니코드는 0 ~ 65535 범위의 2byte 크기를 가진 정수값이다.
- 0~127까지는 야스키 문자 (특수 기호 및 영어 알파벳)이 할당되어있고, 44032~55203까지는 한글 11172가 할당되어있다.
- 유니코드는 음수가 없기 때문에 char 타입의 변수에는 음수 값을 저장할 수 없다.
- char 타입 변수에 작은 따옴표 감싼 문자를 대입하면 해당 문자의 유니코드가 저장된다.
- ‘작은 따옴표로 감싼 문자를 대입하면 해당 문자의 유니코드가 저장된다.
- 작은 따옴표로 감싸지 않아도 직접 유니코드 정수값을 저장할 수 도있다.
    - 특정 문자의 유니코드를 안다면 10진수 또는 16진수로 저장하면 된다
        - 문자 A는 10진수로 65이고 16진수로 0x41이므로
        - char c = 65;
        - char c = ‘\0041’;  (  ‘\u+16진수값’ )
- 프로그램 코드에서 char 변수에 저장된 유니코드를 알고 싶다면 char 타입 변수를 int 타입 변수에 저장하면된다.
    - char c = ‘A’;
    - int uniCode = c;
- System.out.println()은 변수의 타입이 char이면 유니코드에 해당하는 문자를 출력한다.

### String

- 만약 문자열을 저장하고 싶다면 String 타입을 사용해야 하는데, 다음과 같이 String 변수를 선언하고 큰 따옴표로 감싼 문자열 리터럴을 대입하면된다.
    - String name = “홍길동”;
- String은 기본 타입이 아니고 String은 클래스 타입이고 String 변수는 참조변수이다.
- 문자열 String 변수에 대입하면 문자열이 변수에 직접 저장되는 것이아니라 String 객체가 생성되고, String 변수는 String 객체의 번지를 참조하게된다.
- 여기서는 간단하게만 이정도로만 알거임!

### short 타입

- short타입은 2byte(16bit)로 표현되는 정수값을 저장할 수 있는 데이터 타입이고 -32,768 ~ 32,767의 범위를 가진다.
- C언어와의 호환을 위해 사용되며 비교적 자바에서는 잘 사용되지 않는 타입이다.

### int 타입

- int 타입은 4byte 로 표현되는 정수값을 저장할 수 잇는 데이터 타입이고 -2,147,483,648 ~ 2,147,483,647의 범위를 가진다.
- 자바에서 정수 연산을 하기 위한 기본타입으로 short byte타입의 변수를 + 연산하면 int타입으로 변환된 후 연산되고 결과 역시 int 타입이 된다.
    - 정수 연산을 4byte으로 처리하기 때문에
- 정수값을 직접 코드에 입력할 경우 8진수, 10진수, 16진수로 표현할 수 있다.
    - int number = 10;
    - int octNumber = 012;  (8진수: 숫자앞에 0)
    - int hexNumber = 0xA;  (16진수는 0x)

### long 타입

- long 타입은 8byte로 표현되는 정수값을 저장할 수 있는 데이터 타입, -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,808 범위를 갖는다.
- 은행 및 우주와 관련된 수치가 큰 데이터를 다루는 프로그램에서 필수적으로 사용된다.
- long타입의 변수를 초기화할 때에는 정수값 뒤에 소문자 l이나 대문자 L을 붙여 알려준다.
- int 타입의 저장 범위를 넘어서는 정수는 반드시 붙여줘야 안그럼 컴파일 에러가 난다. 보통 대문자를 붙임

### 2.2.3 실수 타입(float, double)

- 실수 타입은 소수점이 있는 실수 데이터를 저장할 수 있는 타입으로 메모리 크기에 따라 float과 double이 있다.
- float과 double의 메모리 사용 크기는 각각 int와 long의 크기와 같지만 정수 타입과는 다른 저장 방식으로 정수 타입보다 훨씬 큰 범위의 값을 저장할 수 있다.
- 실수는 정수와 달리 부동 소수점 방식으로 저장된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/de4e3c9d-6400-429e-87f8-eceb13c4cb90/66eacb32-1c84-4478-a092-5bd1eaf2599f/Untitled.png)

- 가수 m은 0 ≤ m < 1 범위의 실수이어야한다.
- 예를 들어 실수 1.2345는 부동 소수점 방식으로 표현하면 0.12345 x 10^3이며 가수는 0.12345이고 지수는 1이 된다.
- float에 비해 double이 가수를 표현하는데 있어서 약 두배의 자릿수가 배정되어있어 더 정밀한 값을 저장할 수 있다.
- 자바는 리터럴의 기본 타입을 double로 간주한다.
- 실수 리터럴을 float타입 변수로 저장하려면 리터럴 뒤에 소문자 f나 대문자 F를 붙여야한다.

## 2.2.4 논리 타입

- boolean 타입은 1byte(8bit)로 표현되는 논리값을 저장할 수 있는 데이터 타입이다.
- 두 가지 상태값을 저장할 필요성이 잇을 경우에 사용되며 상태값에 따라 조건문과 제어문의 실행 흐름을 변경하는데 주로 이용된다.

<aside>
💡 boolan stop = true;

if(stop) {
System.out.println(”중지합니다.”);
} else {
System.out.println(”시작합니다.”);

</aside>

## 2.3 타입 변환

- 타입 변환이란 데이터 타입을 다른 데이터 타입으로 변환하는 것을 말한다.
- 타입 변환에는 자동(묵시적) 타입 변환과 강제(명시적)타입 변환이 있다.

## 2.3.1 자동 타입 변환

- 자동 타입 변환은 프로그램 실행 도중에 자동으로 타입 변환이 일어나는 것을 말한다.
- 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생한다.
    - byte (1) < short(2) < int(4) < long(8) < float(4) < double(8)
- float은 4byte 크기인데 int와 long보다 더 큰 타입으로 표시한 이유는 표현할 수 있는 값의 범위가 float이 더 크기 때문이다.

<aside>
💡 byte byteValue = 10;
int intValue = byteValue;   //자동 타입 변환이 일어난다.

</aside>

- 정수에서 실수타입으로 변환하는 것은 무조건 자동 타입 변환이 된다.
    - 실수 타입으로 변환된 이후의 값은 정수값이 아닌 .0이 부은 실수값이 된다.
- 자동 타입 변환에서 단 하나 예외가 있는데 char는 2byte의 크기를 가지지만 char 범위는 0~ 65535이므로 음수가 저장될 수 없다.
- 따라서 음수가 저장될 수 있는 byte타입을 char 타입으로 자동 변환시킬 수 없다.

## 2.3.2 강제 타입 변환

- 큰 크기의 타입은 작은 크기의 타입으로 자동 타입 변환을 할 수 없다.
- int 타입을 4개의 byte로 쪼갠 후 끝에 있는 1byte만 byte타입 변수에 저장하는 것은 가능하다.
- 이와같이 강제적으로 큰 데이터 타입을 작은 데이터 타입으로 쪼개어서 저장하는 것을 강제 타입 변환이라고 한다.
- 강제 타입 변환은 캐스팅 연산자 ()를 사용하는데 괄호 안에 들어가는 타입은 쪼개는 단위이다.

<aside>
💡 int intValue = 103829770;
byte byteValue = (byte) intValue;    //강제 타입 변환(캐스팅)

</aside>

- 끝 1byte만 byte 타입 변수에 담게 되므로 원래 int 값은 보존되지 않는다.
- 하지만 int 값이 끝 1byte로만 표현이 가능하다면 byte 타입으로 변환해도 같은 값이 유지될 수있다.
- 이럴 경우 강제 타입 변환이 의미 있게 된다.
    - int 타입 변수 10을 저장할 경우 4byte 중 끝 1byte로 10을 충분히 표현할 수 있으므로 3byte는 모두 0으로 채워진다.
    - 이것을 byte 타입으로 강제 타입 변환할 경우 앞 3byte는 버려지고 끝 1byte만 byte 타입 변수에 저장되기 때문에 10이 그대로 유지된다.
    - 다른 예로는 long 타입 변수에 300이 저장되어 있을 경우 8byte중 끝의 4byte로 300을 충분히 표현할 수 있으므로 끝 4byte만 int 타입 변수에 저장되어 300이 그대로 유지된다.
- int타입은 char 타입으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야 한다.
- int 타입에 저장된 값이 유니코드 범위라면 캐스팅 연자를 사용해서 char 타입으로 변환할 수 있다

<aside>
💡 int intValue = ‘A’;
char charValue = (char)) intValue;
System.out.println(charValue);

</aside>

- 실수 타입(float, double)은 정수 타입(byte, short, int, long)으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야한다. 이경우 소수점 이하 부분은 버려지고 정수 부분만 저장된다.
- 강제 타입 변환에서 주의해야할 점은 값을 변환할 때 값의 손실이 발생하면 안된다는 것이다.
- 강제 타입 변환 전 안전하게 값이 보존될 수 있는지 검사하는 것이 좋다.

```java
public class 이거슨자바다 {
public static void main(String[] args) {
int i = 128;
   if( (i<Byte.MIN_VALUE) || (i>Byte.MAX_VALUE)) {
 
          System.out.println("byte타입으로 변환할 수 없습니다.");
          System.out.println("값을 다시 확인해주세요");
      } else {
          byte b = (byte)i;
          System.out.println(b);
      }
  }
}
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/de4e3c9d-6400-429e-87f8-eceb13c4cb90/4e9bdd05-3287-45ea-ad1a-a4c24f905c89/Untitled.png)

- 강제 타입 변환에서 다른 주의점!
- 정수 타입을 실수 타입으로 변환할 때 정밀도 손실을 피해야한다.

<aside>
💡

```
public static void main(String[] args) {

    int num1 = 123456789;
    int num2 = 123456789;

    float num3  = num2;
    num2  = (int) num3;

    int result = num1 - num2;
    System.out.println(result);
}

```

</aside>

- num1, num2에 동일한 값을 넣고 num2를 float로 변환시킨후 다시 int타입으로 변환해서 num2에 저장한다, 그 후 num1-num2를 뺀결과 동일한 값을 뺐지만 0이 나오지 않는다. 이러한 이유는 float 타입은 다음과 같이 비트수가 할당되어있다.

<aside>
💡 float : 부호(1비트)) + 지수(8비트) + 가수(2비트)

</aside>

- int 값을 손실 없이 float 타입의 값으로 변환할 수 있으려면 가수 23비트로 표현가능한 값이어야한다.
- 123456789은 23비트로 표현할 수 없기 때문에 근사치로 변환된다.
- 즉 정밀도 손실이 발생한다.
- 해결책은 모든 int값을 실수 타입으로 안전하게 변환시키는 double 타입을 사용하는 것이다.

<aside>
💡 double :  부호(1비트) + 지수(11비트) + 가수 (52비트)

</aside>

- int의 크기는 32비트이므로 double의 기수 52비트보다 작기 때문에 어떠한 값도 정밀도 손실없이 double 타입으로 변환될 수 있다.

### 2.3.3 연산식에서의 자동 타입 변환

- 연산은 기본적으로 같은 타입의 피연산자 간에만 수행되기 때문에 서로 다른 타입의 피연산자가 있을 경우 큰 타입으로 자동 변환된 후 연산을 수행한다.
    - int 타입 피연산자와 double 타입 피연산자를 덧셈 연산하면 먼저 int 타입 피연산자가 double 타입으로 변환되고 연산을 수행한다.
    - 연산의 결과는 double
- 만약 int 타입으로 꼭 연산을 해야 한다면 double 타입을 int 타입으로 강제 변환하고 덧셈 연산을 수행하면 된다.
- 자바는 정수 연산일 경우 int 타입을 기본으로 한다. 그유는 피연산자를 4byte단위로 저장하기 때문에 작은 타입은 int타입으로 변환딘 후 연산이 수행되고 연산의 결과도 int타입이 된다.

- char 타입의 연산 결과는 int 타입으로 산출되므로 int 타입 변수에 결과를 저장해야 한다.
- 연산의 결과를 다시 문자로 출력하거나 저장하려면 int 결과값을 char타입으로 강제변환해야한다.

<aside>
💡 char ai = ‘A’;
int result = ai + 1;     //’A’의 유니코드보다 1이 큰 유니코드가 저장
char na = (char) result;   //’B’가 저장됨

</aside>

- 만약 피연산자 중 하나가 long 타입이라면 다른 피연산자도 long 결과값도 long타입이 된다.
- float 타입과 float 타입을 연산하면 결과는 float타입이지만  피연산자 중에 실수 리터럴이나 double 타입이 있다면 다른 피연산자도 double 타입으로 자동변환되어 결과도 double 타입으로 산출된다.